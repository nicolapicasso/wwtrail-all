// lib/api/seo.service.ts
import apiClientV2 from './client-v2';

export interface SEOConfig {
  id: string;
  entityType: string;
  metaTitleTemplate?: string;
  metaDescriptionTemplate?: string;
  qaPrompt?: string;
  availableVariables?: string[];
  autoGenerate: boolean;
  generateOnCreate: boolean;
  generateOnUpdate: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface SEO {
  id: string;
  entityType: string;
  entityId?: string;
  slug?: string;
  metaTitle?: string;
  metaDescription?: string;
  llmFaq?: Array<{ question: string; answer: string }>;
  autoGenerated: boolean;
  lastRegenerated?: string;
  createdAt: string;
  updatedAt: string;
}

export interface GenerateSEOInput {
  entityType: string;
  entityId?: string;
  slug?: string;
  data: Record<string, any>;
}

export interface UpsertConfigInput {
  entityType: string;
  metaTitleTemplate?: string;
  metaDescriptionTemplate?: string;
  qaPrompt?: string;
  availableVariables?: string[];
  autoGenerate?: boolean;
  generateOnCreate?: boolean;
  generateOnUpdate?: boolean;
}

class SEOService {
  // ==========================================
  // CONFIGURACIÓN
  // ==========================================

  /**
   * Listar todas las configuraciones
   */
  async listConfigs(): Promise<SEOConfig[]> {
    const response = await apiClientV2.get('/seo/config');
    return response.data.data;
  }

  /**
   * Obtener configuración de un tipo de entidad
   */
  async getConfig(entityType: string): Promise<SEOConfig> {
    const response = await apiClientV2.get(`/seo/config/${entityType}`);
    return response.data.data;
  }

  /**
   * Crear o actualizar configuración
   */
  async upsertConfig(data: UpsertConfigInput): Promise<SEOConfig> {
    const response = await apiClientV2.post('/seo/config', data);
    return response.data.data;
  }

  // ==========================================
  // GESTIÓN DE SEO
  // ==========================================

  /**
   * Obtener SEO de una entidad específica
   */
  async getSEO(entityType: string, entityId: string, language: string = 'ES'): Promise<SEO | null> {
    try {
      const response = await apiClientV2.get(`/seo/${entityType}/${entityId}`, {
        params: { language: language.toUpperCase() },
      });
      return response.data.data;
    } catch (error: any) {
      if (error.response?.status === 404) {
        return null;
      }
      throw error;
    }
  }

  /**
   * Listar SEO de un tipo de entidad
   */
  async listSEO(
    entityType: string,
    page: number = 1,
    limit: number = 20
  ): Promise<{
    data: SEO[];
    meta: {
      page: number;
      limit: number;
      total: number;
      totalPages: number;
    };
  }> {
    const response = await apiClientV2.get(`/seo/list/${entityType}`, {
      params: { page, limit },
    });
    return response.data;
  }

  /**
   * Generar SEO para una entidad
   */
  async generateSEO(input: GenerateSEOInput): Promise<SEO> {
    const response = await apiClientV2.post('/seo/generate', input);
    return response.data.data;
  }

  /**
   * Regenerar SEO (eliminar y crear de nuevo)
   */
  async regenerateSEO(input: GenerateSEOInput): Promise<SEO> {
    const response = await apiClientV2.post('/seo/regenerate', input);
    return response.data.data;
  }

  /**
   * Actualizar SEO manualmente
   */
  async updateSEO(
    id: string,
    data: {
      metaTitle?: string;
      metaDescription?: string;
      llmFaq?: Array<{ question: string; answer: string }>;
    }
  ): Promise<SEO> {
    const response = await apiClientV2.put(`/seo/${id}`, data);
    return response.data.data;
  }

  /**
   * Eliminar SEO
   */
  async deleteSEO(id: string): Promise<void> {
    await apiClientV2.delete(`/seo/${id}`);
  }
}

export const seoService = new SEOService();
